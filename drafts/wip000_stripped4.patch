diff --git a/devtools/client/netmonitor/src/connector/firefox-data-provider.js b/devtools/client/netmonitor/src/connector/firefox-data-provider.js
index 0a85eb487e..0af5cabe6e 100644
--- a/devtools/client/netmonitor/src/connector/firefox-data-provider.js
+++ b/devtools/client/netmonitor/src/connector/firefox-data-provider.js
@@ -165,7 +165,7 @@ class FirefoxDataProvider {
       this.fetchRequestHeaders(requestHeaders),
       this.fetchResponseHeaders(responseHeaders),
       this.fetchEarlyHintResponseHeaders(earlyHintsResponseHeaders),
-      this.fetchPostData(requestPostData),
+      this.fetchPostData(requestPostData || { from: id } ), //eg. {"from":"server0.conn0.netEvent73"}
       this.fetchRequestCookies(requestCookies),
       this.fetchResponseCookies(responseCookies),
       this.fetchResponseCache(responseCache),
@@ -239,25 +239,178 @@ class FirefoxDataProvider {
   }
 
   async fetchPostData(requestPostData) {
+    //XXX: dump() are visible on terminal if about:config setting browser.dom.window.dump.enabled is true
+    dump("fetchPostData called with input: " + (requestPostData ? JSON.stringify(requestPostData) : "undefined") + "\n");
+    //const payload = { requestPostData: { postData: null, uploadHeaders: null } };
     const payload = {};
-    if (requestPostData?.postData) {
-      const { text } = requestPostData.postData;
-      const postData = await this.getLongString(text);
-      const headers = CurlUtils.getHeadersFromMultipartText(postData);
-
-      // Calculate total header size and don't forget to include
-      // two new-line characters at the end.
-      const headersSize = headers.reduce((acc, { name, value }) => {
-        return acc + name.length + value.length + 2;
-      }, 0);
-
-      requestPostData.postData.text = postData;
-      payload.requestPostData = {
-        ...requestPostData,
-        uploadHeaders: { headers, headersSize },
-      };
+    // ^ originally this would return {} for blocked requests
+
+    let requestId = requestPostData?.requestId || requestPostData?.from; // Try input
+    dump("Initial requestId: " + requestId + "\n");
+
+    if (!requestId) {
+      dump("No requestId from input\n"); // No owner, no fallback
+      //payload.requestPostData = {};
+      //payload.requestPostData.postData = { text: null };
+      //payload.requestPostData.uploadHeaders = { headers: [], headersSize: 0 };
+      return payload;
     }
-    return payload;
+
+    try {
+      const networkEvents = await this.commands.resourceCommand.getAllResources("network-event");
+      dump("Network events count: " + networkEvents.length + "\n");
+      const event = networkEvents.find(e => e.actor === requestId || e.resourceId === requestId || e.channelId === requestId); // Prioritize actor match
+      if (!event || !event.actor) {
+        dump("No event or actor found for requestId: " + requestId + "\n");
+        //payload.requestPostData.postData = { text: null };
+        //payload.requestPostData.uploadHeaders = { headers: [], headersSize: 0 };
+        return payload;
+      }
+
+      dump("Found event: resourceId=" + event.resourceId + ", channelId=" + event.channelId + ", actor=" + event.actor + "\n");
+
+      let postDataText;
+      const client = this.commands.client;
+      const actorId = event.actor;
+      dump("Sending getRequestPostData to actor: " + actorId + "\n");
+
+      let theLongStringActorPostData=null;
+      try {
+        const packet = { to: actorId, type: "getRequestPostData" };
+        const startTime = Date.now();
+        const postDataResponse = await Promise.race([
+          client.request(packet),
+          new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout after 2000ms")), 2000))
+        ]);
+        const elapsed = Date.now() - startTime;
+        dump("PostData response: " + JSON.stringify(postDataResponse) + " after " + elapsed + "ms\n");
+
+        if (postDataResponse.postData) {
+          theLongStringActorPostData=postDataResponse.postData;
+        }
+
+        if (postDataResponse.postData?.text?.substring) {
+          postDataText = await postDataResponse.postData.text.substring(0, postDataResponse.postData.text.length);
+          dump("Extracted LongStringActor text: " + postDataText + "\n");
+        } else {
+          postDataText = postDataResponse.postData?.text;
+          dump("Extracted text: " + (postDataText || "null") + "\n");
+        }
+      } catch (e) {
+        dump("Error fetching postData: " + e + "\n");
+        postDataText = null;
+        dump("Falling back to null\n");
+      }
+
+
+
+      if (postDataText) {
+        payload.requestPostData = {};
+        payload.requestPostData.uploadHeaders = { headers: [], headersSize: 0 }; //XXX: without these being empty, it won't auto-apply the "Form data" view for example, it's all Raw.
+        //original curl headers code logic, hopefully.
+        try {
+          //if (requestPostData?.postData) {
+          if (theLongStringActorPostData) {
+            //const { text } = requestPostData.postData;
+            const { text } = theLongStringActorPostData;
+            //that 'text' is a LongStringActor, supposedly, from getRequestPostData() function's return.
+            const postData = await this.getLongString(text);//XXX: 'text' here must be LongStringActor else(sometimes?) u get: "JavaScript error: resource://devtools/client/shared/string-utils.js, line 19: TypeError: can't access property "type", stringGrip is null"
+            //const postData=await this.getLongString(postDataText);//before processing it like below
+            const headers = CurlUtils.getHeadersFromMultipartText(postData);
+
+            // Calculate total header size and don't forget to include
+            // two new-line characters at the end.
+            const headersSize = headers.reduce((acc, { name, value }) => {
+              return acc + name.length + value.length + 2;
+            }, 0);
+            //requestPostData.postData.text = postData;
+            dump("!!! for curl, postData="+postData+"\n");
+
+            //      const headers = CurlUtils.getHeadersFromMultipartText(requestPostData/*the func arg!*/);//postDataText || "");
+            //      const headersSize = headers.reduce((acc, { name, value }) => acc + name.length + value.length + 2, 0);
+            dump("Headers from CurlUtils: " + JSON.stringify(headers) + ", Size: " + headersSize + "\n");
+            // always(so far): Headers from CurlUtils: [], Size: 0
+            payload.requestPostData.uploadHeaders = { headers, headersSize };
+          } else {
+            dump("!! got nothing from the curl block.\n");
+            //payload.requestPostData.uploadHeaders = { headers: [], headersSize: 0 }; //XXX: without these being empty, it won't auto-apply the "Form data" view for example, it's all Raw.
+          } // if else
+        } catch (e) {
+          dump("Error with CurlUtils: " + e + "\n");//keep
+          //payload.requestPostData.uploadHeaders = { headers: [], headersSize: 0 }; //XXX: without these being empty, it won't auto-apply the "Form data" view for example, it's all Raw.
+        } //curl logic ends.
+
+        //const isBinary = /[\x00-\x1f]/.test(postDataText); // Any control char < 0x20
+        const isBinary = /[\x00-\x08\x0b\x0c\x0e-\x1f]/.test(postDataText); // Control chars except tab, newline, CR
+        // Process binary data
+        if (isBinary) {
+          dump("Detected binary payload, original text as hex: " +
+            Array.from(postDataText, char => char.charCodeAt(0).toString(16).padStart(2, "0")).join(" ") + "\n");
+
+          // Store raw text before we mess with it
+          const rawText = postDataText;
+
+          // Split on single quotes, process each chunk for printf
+          const chunks = postDataText.split("'");
+          const processedChunks = chunks.map(chunk =>
+            Array.from(chunk, char => {
+              const code = char.charCodeAt(0);
+              if (code < 0x20) return "\\x" + code.toString(16).padStart(2, "0"); // Control chars
+              if (char === "\\") return "\\\\"; // Escape backslash
+              //if (char === "%") return "%%"; // Escape percent, XXX: no need if: printf '%b' 'payload', and a -- isn't needed either after '%b' due to how '%b' works and treat it as raw text, but u can do printf -- '%b' ...
+              return char; // Everything else (including %) as-is
+            }).join("")
+          );
+          const escapedForPrintf=processedChunks.join("'$\"'\"'");//for when using '%b' as first arg of printf!
+
+          // Generate hex dump with offset, hex, and raw text, 16 chars (8 bytes) per line
+          const bytes = Array.from(rawText);
+          const hexxedLines = [];
+          for (let i = 0; i < bytes.length; i += 8) {
+            const offset = i.toString(16).padStart(8, "0"); // 8-digit hex offset
+            const hexChunk = bytes.slice(i, i + 8)
+              .map(char => char.charCodeAt(0).toString(16).padStart(2, "0"))
+              .join(" ");
+            const rawChunk = bytes.slice(i, i + 8)
+              .map(char => {
+                const code = char.charCodeAt(0);
+                return (code < 0x20 || code > 0x7e) ? "." : char; // Unprintable as "."
+              }).join("");
+            hexxedLines.push(`${offset}: ${hexChunk.padEnd(23, " ")} | ${rawChunk}`);
+          }
+          const hexxed = hexxedLines.join("\n");
+
+
+          // Join with bash-safe single quote concatenation
+          postDataText = "This is your modded firefox saying that\n"+
+            " this request payload is binary\n"+
+            " therefore to see it raw\n"+
+            " you could do this in bash(long line follows btw):\n\n"+
+            // note a "--" isn't needed due to '%b' treating everything after as the text, not args!
+            "printf -- '%b' '" + escapedForPrintf + "'\n\n"+
+            " and maybe redirect that by appending this to it:\n"+
+            " >binary_payload.bin && xxd -g 1 -c 8 -- binary_payload.bin\n\n"+
+            "You should turn on Raw(top right) so it's monospaced\n"+
+            " and it's not interpreted like Form data(if it is)\n\n"+
+            "Otherwise here's a hex view of it:\n\n" +
+            hexxed +"\n\n"+
+            "And here's what it woulda been shown as,\n if we didn't get in the way at all:\n" + rawText;
+          dump("Processed binary text: " + postDataText + "\n");
+        } // if bin
+        dump("!!! will return this *.postData="+postDataText+"\n");
+        const postData=await this.getLongString(postDataText);
+        dump("!!! will return it as long string:"+postData+"\n");
+        payload.requestPostData.postData = { text: postData };
+      } // if not empty
+
+    } catch (e) {
+      dump("Outer error: " + e + "\n");
+      //payload.requestPostData.postData = { text: null };
+      //payload.requestPostData.uploadHeaders = { headers: [], headersSize: 0 };
+    }
+
+    dump("Returning payload: " + JSON.stringify(payload) + "\n");
+    return payload; //can be {}
   }
 
   async fetchRequestCookies(requestCookies) {
diff --git a/devtools/client/netmonitor/src/utils/request-utils.js b/devtools/client/netmonitor/src/utils/request-utils.js
index baa3c28a29..77afb5a647 100644
--- a/devtools/client/netmonitor/src/utils/request-utils.js
+++ b/devtools/client/netmonitor/src/utils/request-utils.js
@@ -56,7 +56,9 @@ async function getFormDataSections(
     ? contentTypeHeader.value
     : "";
 
+  dump("!!! helooo\n");
   const contentType = await getLongString(contentTypeLongString);
+  dump("!!!2 "+contentType+"\n");
 
   if (contentType && contentType.includes("x-www-form-urlencoded")) {
     const postDataLongString = postData.postData.text;
@@ -563,12 +565,18 @@ async function updateFormDataSections(props) {
     requestPostDataAvailable,
   } = request;
 
+  dump("!!!ok1 before headers check\n");
   if (requestHeadersAvailable && !requestHeaders) {
+    dump("!!!ok2 requesting headers\n");
     requestHeaders = await connector.requestData(id, "requestHeaders");
+    dump("!!!ok2_2 after requesting headers\n");
   }
 
+  dump("!!!ok3 before checking requestPostData\n");
   if (requestPostDataAvailable && !requestPostData) {
+    dump("!!!ok4 before requesting requestPostData\n");
     requestPostData = await connector.requestData(id, "requestPostData");
+    dump("!!!ok5 after requesting requestPostData\n");
   }
 
   if (
diff --git a/devtools/server/actors/network-monitor/network-event-actor.js b/devtools/server/actors/network-monitor/network-event-actor.js
index 9e5a16ba46..fa362beb2f 100644
--- a/devtools/server/actors/network-monitor/network-event-actor.js
+++ b/devtools/server/actors/network-monitor/network-event-actor.js
@@ -77,6 +77,92 @@ class NetworkEventActor extends Actor {
   ) {
     super(conn, networkEventSpec);
 
+    this._channel = channel;
+    this._postDataText = null;
+    dump("NetworkEventActor constructor, channel: " + (channel ? "present" : "null") + "\n");
+    if (channel) {
+      //dump("Channel type: " + this._channel.constructor.name + "\n");
+      //dump("Channel proto: " + Object.getPrototypeOf(this._channel).constructor.name + "\n");
+      dump("Channel methods: " + Object.getOwnPropertyNames(this._channel).join(", ") + "\n");
+      //const iface = Components.interfacesByID[this._channel.QueryInterface(Components.ID).toString()];
+      //dump("Channel XPCOM interface: " + (iface ? iface.name : "unknown") + "\n");
+      dump("Channel type (toString): " + this._channel.toString() + "\n");
+      dump("Channel constructor: " + (this._channel.constructor ? this._channel.constructor.name : "no constructor") + "\n");
+
+      // List properties
+      const props = Object.getOwnPropertyNames(this._channel).join(", ");
+      dump("Channel properties: " + (props || "none") + "\n");
+
+      // Check specific interfaces
+//      try {
+//        if (this._channel instanceof Ci.nsIHttpChannel) {
+//          dump("Channel is nsIHttpChannel: yes\n");
+//        } else {
+//          dump("Channel is nsIHttpChannel: no\n");
+//        }
+//      } catch (e) {
+//        dump("Instance check failed: " + e + "\n");
+//      }
+      let isHttpChannel = false;
+      try {
+        if (this._channel instanceof Ci.nsIHttpChannel) {
+          dump("Channel is nsIHttpChannel: yes\n");
+          isHttpChannel = true;
+        } else {
+          dump("Channel is nsIHttpChannel: no\n");
+        }
+      } catch (e) {
+        dump("Instance check failed: " + e + "\n");
+      }
+
+      if (isHttpChannel) {
+
+        try {
+          dump("Attempting getPostDataText\n");
+          let text = {};
+          channel.getPostDataText(text);
+          dump("getPostDataText called, text: " + (text.value || "empty") + "\n");
+          if (text.value) { //wtf grok3: && text.value !== "[]" && text.value.trim()) { // Changed: Only set if non-empty and not []
+            this._postDataText = text.value;
+            dump("Stored postDataText: " + this._postDataText + "\n");
+          } else {
+            dump("No valid postDataText from channel\n"); // Added: Log skip
+          }
+        } catch (e) {
+          dump("Initial getPostDataText call failed: " + e + "\n");
+        }
+      } else {
+        dump("Non-HTTP channel, skipping getPostDataText but trying the mLoadInfo way:\n");
+        if (this._channel?.loadInfo) {
+          try {
+            this._postDataText = this._channel.loadInfo.customPostDataText;
+            // Changed: Add null check for logging
+            if (this._postDataText) {
+              dump("Set postDataText from loadInfo.customPostDataText: " + this._postDataText + "\n");
+            } else {
+              dump("it was empty in loadInfo.customPostDataText");
+            }
+          } catch (e) {
+            dump("loadInfo getPostDataText failed: " + e + "\n");
+          }
+        }
+//        try {
+//          let postDataProp = this._channel.getProperty("postDataText");
+//          dump("getProperty result: " + (postDataProp || "null") + "\n");
+//          if (postDataProp) {
+//            this._postDataText = postDataProp;
+//            dump("Set postDataText from property: " + this._postDataText + "\n");
+//          } else {
+//            dump("No postDataText property found\n");
+//          }
+//        } catch (e) {
+//          dump("getProperty failed: " + e + "\n");
+//        }
+      }//else
+    } else {
+      dump("No channel in constructor\n");
+    }
+
     this._sessionContext = sessionContext;
     this._onNetworkEventUpdate = onNetworkEventUpdate;
     this._onNetworkEventDestroy = onNetworkEventDestroy;
@@ -316,19 +402,40 @@ class NetworkEventActor extends Actor {
    *         The response packet - network POST data.
    */
   getRequestPostData() {
+    dump("getRequestPostData called, channel: " + (this._channel ? "present" : "null") + ", request.postData.text: " + (this._request.postData.text || "null") + ", stored postDataText: " + (this._postDataText || "null") + "\n"); // Changed: Log all sources
     let postDataText;
-    if (this._request.postData.text) {
-      // Create a long string actor for the postData text if needed.
+    if (this._request.postData.text) { //wtf: && this._request.postData.text !== "[]") { // Changed: Skip if empty array
       postDataText = this._createLongStringActor(this._request.postData.text);
+      dump("Returning original postData as LongStringActor: " + this._request.postData.text + "\n"); // Changed: Log value
+      return {
+        postData: { text: postDataText, size: this._request.postData.size },
+        postDataDiscarded: this._discardRequestBody,
+      };
     }
-
-    return {
-      postData: {
-        size: this._request.postData.size,
-        text: postDataText,
-      },
-      postDataDiscarded: this._discardRequestBody,
-    };
+    if (this._postDataText) { //wtf: && this._postDataText !== "[]") { // Changed: Skip if empty array
+      postDataText = this._createLongStringActor(this._postDataText);
+      dump("Returning stored postDataText as LongStringActor: " + this._postDataText + "\n"); // Changed: Log value
+      return { postData: { text: postDataText, size: this._postDataText.length }, postDataDiscarded: false };
+    }
+    if (!this._channel) {
+      dump("No channel available\n");
+      return { postData: { size: 0, text: null }, postDataDiscarded: false };
+    }
+    try {
+      let text = {};
+      this._channel.getPostDataText(text);
+      dump("Live channel getPostDataText, text: " + (text.value || "empty") + "\n");
+      if (text.value) { //wtf: && text.value !== "[]") { // Changed: Skip if empty array
+        postDataText = this._createLongStringActor(text.value);
+        dump("Returning live postData as LongStringActor: " + text.value + "\n"); // Changed: Log value
+        return { postData: { text: postDataText, size: text.value.length }, postDataDiscarded: false };
+      }
+      dump("No valid live postData available\n");
+    } catch (e) {
+      dump("Live channel getPostDataText failed: " + e + "\n");
+    }
+    dump("Falling back to empty payload\n");
+    return { postData: { size: 0, text: null }, postDataDiscarded: false };
   }
 
   /**
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
index 1ec2c64193..99cb493e3f 100644
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -103,6 +103,19 @@ static nsContentPolicyType InternalContentPolicyTypeForFrame(
       aContentPolicyType, aSecurityFlags, aSandboxFlags);
 }
 
+// netwerk/base/LoadInfo.cpp
+NS_IMETHODIMP
+LoadInfo::GetCustomPostDataText(nsAString& aCustomPostDataText) {
+  aCustomPostDataText = mCustomPostDataText; // New: Return our string
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+LoadInfo::SetCustomPostDataText(const nsAString& aCustomPostDataText) {
+  mCustomPostDataText = aCustomPostDataText; // New: Set our string
+  return NS_OK;
+}
+
 LoadInfo::LoadInfo(
     nsIPrincipal* aLoadingPrincipal, nsIPrincipal* aTriggeringPrincipal,
     nsINode* aLoadingContext, nsSecurityFlags aSecurityFlags,
diff --git a/netwerk/base/LoadInfo.h b/netwerk/base/LoadInfo.h
index 93cc8d3630..2f0bfc6737 100644
--- a/netwerk/base/LoadInfo.h
+++ b/netwerk/base/LoadInfo.h
@@ -66,6 +66,7 @@ class LoadInfo final : public nsILoadInfo {
   NS_DECL_ISUPPORTS
   NS_DECL_NSILOADINFO
 
+
   // Used for TYPE_DOCUMENT load.
   static already_AddRefed<LoadInfo> CreateForDocument(
       dom::CanonicalBrowsingContext* aBrowsingContext, nsIURI* aURI,
@@ -106,6 +107,7 @@ class LoadInfo final : public nsILoadInfo {
            uint32_t aSandboxFlags);
 
  private:
+  nsString mCustomPostDataText; // Add this
   // Use factory function CreateForDocument
   // Used for TYPE_DOCUMENT load.
   LoadInfo(dom::CanonicalBrowsingContext* aBrowsingContext, nsIURI* aURI,
diff --git a/netwerk/base/TRRLoadInfo.cpp b/netwerk/base/TRRLoadInfo.cpp
index d1650595f8..f47f7abc42 100644
--- a/netwerk/base/TRRLoadInfo.cpp
+++ b/netwerk/base/TRRLoadInfo.cpp
@@ -5,6 +5,9 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "TRRLoadInfo.h"
+// Changed: Add full LoadInfo definition
+//#include "LoadInfo.h"
+
 #include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/FeaturePolicy.h"
 #include "mozilla/dom/DOMTypes.h"
@@ -950,5 +953,29 @@ TRRLoadInfo::GetFetchDestination(nsACString& aDestination) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+NS_IMETHODIMP
+TRRLoadInfo::GetCustomPostDataText(nsAString& aCustomPostDataText) {
+  // Changed: Use our own field
+  aCustomPostDataText = mCustomPostDataText;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+TRRLoadInfo::SetCustomPostDataText(const nsAString& aCustomPostDataText) {
+  // Changed: Use our own field
+  mCustomPostDataText = aCustomPostDataText;
+  return NS_OK;
+}
+
+//NS_IMETHODIMP
+//TRRLoadInfo::GetCustomPostDataText(nsAString& aCustomPostDataText) {
+//  return LoadInfo::GetCustomPostDataText(aCustomPostDataText); // Delegate to parent
+//}
+//
+//NS_IMETHODIMP
+//TRRLoadInfo::SetCustomPostDataText(const nsAString& aCustomPostDataText) {
+//  return LoadInfo::SetCustomPostDataText(aCustomPostDataText); // Delegate to parent
+//}
+
 }  // namespace net
 }  // namespace mozilla
diff --git a/netwerk/base/TRRLoadInfo.h b/netwerk/base/TRRLoadInfo.h
index 25f588c96f..3b2c071df3 100644
--- a/netwerk/base/TRRLoadInfo.h
+++ b/netwerk/base/TRRLoadInfo.h
@@ -31,6 +31,8 @@ class TRRLoadInfo final : public nsILoadInfo {
   already_AddRefed<nsILoadInfo> Clone() const;
 
  private:
+  // Changed: Add our own field
+  nsString mCustomPostDataText;
   virtual ~TRRLoadInfo() = default;
 
   nsCOMPtr<nsIURI> mResultPrincipalURI;
diff --git a/netwerk/base/nsILoadInfo.idl b/netwerk/base/nsILoadInfo.idl
index 774ec045c0..86ee5fa78d 100644
--- a/netwerk/base/nsILoadInfo.idl
+++ b/netwerk/base/nsILoadInfo.idl
@@ -260,6 +260,8 @@ interface nsILoadInfo : nsISupports
    */
   readonly attribute nsIPrincipal loadingPrincipal;
 
+  attribute AString customPostDataText;
+
   /**
    * A C++-friendly version of triggeringPrincipal.
    *
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
index 5a38d5a035..d691d96f91 100644
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -68,6 +68,8 @@
 #include "nsCORSListenerProxy.h"
 #include "nsIOService.h"
 
+#include "nsString.h"
+
 #include <functional>
 
 using namespace mozilla::dom;
@@ -155,6 +157,17 @@ HttpChannelChild::~HttpChannelChild() {
   ReleaseMainThreadOnlyReferences();
 }
 
+//NS_IMETHODIMP
+//HttpChannelChild::GetPostDataText(nsAString& aPostDataText) {
+//  aPostDataText = NS_LITERAL_STRING("");
+//  return NS_OK;
+//}
+NS_IMETHODIMP
+HttpChannelChild::GetPostDataText(nsAString& aPostDataText) {
+  aPostDataText.Assign(NS_ConvertUTF8toUTF16(""));
+  return NS_OK;
+}
+
 void HttpChannelChild::ReleaseMainThreadOnlyReferences() {
   if (NS_IsMainThread()) {
     // Already on main thread, let dtor to
diff --git a/netwerk/protocol/http/HttpChannelChild.h b/netwerk/protocol/http/HttpChannelChild.h
index c952065b91..065359bd19 100644
--- a/netwerk/protocol/http/HttpChannelChild.h
+++ b/netwerk/protocol/http/HttpChannelChild.h
@@ -75,6 +75,7 @@ class HttpChannelChild final : public PHttpChannelChild,
 
   HttpChannelChild();
 
+  NS_IMETHOD GetPostDataText(nsAString& aPostDataText) override;
   // Methods HttpBaseChannel didn't implement for us or that we override.
   //
   // nsIRequest
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
index fbf4bdf1e2..b486b660fe 100644
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -21,6 +21,8 @@
 #include "nsQueryObject.h"
 #include "mozilla/Logging.h"
 
+#include "nsString.h" // For nsAString
+
 namespace mozilla::net {
 
 mozilla::LazyLogModule gInterceptedLog("Intercepted");
@@ -69,6 +71,12 @@ void InterceptedHttpChannel::ReleaseListeners() {
   MOZ_DIAGNOSTIC_ASSERT(!LoadIsPending());
 }
 
+NS_IMETHODIMP
+InterceptedHttpChannel::GetPostDataText(nsAString& aPostDataText) {
+  aPostDataText.Assign(NS_ConvertUTF8toUTF16(""));
+  return NS_OK;
+}
+
 nsresult InterceptedHttpChannel::SetupReplacementChannel(
     nsIURI* aURI, nsIChannel* aChannel, bool aPreserveMethod,
     uint32_t aRedirectFlags) {
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
index 704404c9f0..8d9bcdfd83 100644
--- a/netwerk/protocol/http/InterceptedHttpChannel.h
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -221,6 +221,7 @@ class InterceptedHttpChannel final
   TimeStamp mServiceWorkerLaunchEnd;
 
  public:
+    NS_IMETHOD GetPostDataText(nsAString& aPostDataText) override;
   static already_AddRefed<InterceptedHttpChannel> CreateForInterception(
       PRTime aCreationTime, const TimeStamp& aCreationTimestamp,
       const TimeStamp& aAsyncOpenTimestamp);
diff --git a/netwerk/protocol/http/NullHttpChannel.cpp b/netwerk/protocol/http/NullHttpChannel.cpp
index 1038ba82df..147da42fb9 100644
--- a/netwerk/protocol/http/NullHttpChannel.cpp
+++ b/netwerk/protocol/http/NullHttpChannel.cpp
@@ -7,6 +7,7 @@
 #include "nsContentSecurityManager.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIStreamListener.h"
+#include "nsString.h"
 
 namespace mozilla {
 namespace net {
@@ -57,6 +58,12 @@ NullHttpChannel::GetChannelId(uint64_t* aChannelId) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+NS_IMETHODIMP
+mozilla::net::NullHttpChannel::GetPostDataText(nsAString& aPostDataText) {
+  aPostDataText.Assign(NS_ConvertUTF8toUTF16(""));
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 NullHttpChannel::SetChannelId(uint64_t aChannelId) {
   return NS_ERROR_NOT_IMPLEMENTED;
diff --git a/netwerk/protocol/http/NullHttpChannel.h b/netwerk/protocol/http/NullHttpChannel.h
index 478d13e0a2..8689951ee0 100644
--- a/netwerk/protocol/http/NullHttpChannel.h
+++ b/netwerk/protocol/http/NullHttpChannel.h
@@ -56,6 +56,8 @@ class NullHttpChannel final : public nsINullChannel,
   nsCString mTimingAllowOriginHeader;
   bool mAllRedirectsSameOrigin{false};
   bool mAllRedirectsPassTimingAllowCheck{false};
+// public:
+//    NS_IMETHOD GetPostDataText(nsAString& aPostDataText) override;
 };
 
 }  // namespace net
diff --git a/netwerk/protocol/http/ObliviousHttpChannel.cpp b/netwerk/protocol/http/ObliviousHttpChannel.cpp
index 8b7059426c..7a47772b86 100644
--- a/netwerk/protocol/http/ObliviousHttpChannel.cpp
+++ b/netwerk/protocol/http/ObliviousHttpChannel.cpp
@@ -13,6 +13,7 @@
 #include "BinaryHttpRequest.h"
 #include "nsIHttpHeaderVisitor.h"
 #include "nsStringStream.h"
+#include "nsString.h"
 
 namespace mozilla::net {
 
@@ -35,6 +36,12 @@ ObliviousHttpChannel::ObliviousHttpChannel(
   MOZ_ASSERT(mInnerChannelTimed);
 }
 
+NS_IMETHODIMP
+mozilla::net::ObliviousHttpChannel::GetPostDataText(nsAString& aPostDataText) {
+  aPostDataText.Assign(NS_ConvertUTF8toUTF16(""));
+  return NS_OK;
+}
+
 ObliviousHttpChannel::~ObliviousHttpChannel() {
   LOG(("ObliviousHttpChannel dtor [this=%p]", this));
 }
diff --git a/netwerk/protocol/http/ObliviousHttpChannel.h b/netwerk/protocol/http/ObliviousHttpChannel.h
index 9dc9c9f689..df1315e492 100644
--- a/netwerk/protocol/http/ObliviousHttpChannel.h
+++ b/netwerk/protocol/http/ObliviousHttpChannel.h
@@ -34,6 +34,7 @@ class ObliviousHttpChannel final : public nsIObliviousHttpChannel,
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSIUPLOADCHANNEL2
 
+//     NS_IMETHOD GetPostDataText(nsAString& aPostDataText) override;
   ObliviousHttpChannel(nsIURI* targetURI,
                        const nsTArray<uint8_t>& encodedConfig,
                        nsIHttpChannel* innerChannel);
diff --git a/netwerk/protocol/http/TRRServiceChannel.cpp b/netwerk/protocol/http/TRRServiceChannel.cpp
index 58094fa024..97f4185a6e 100644
--- a/netwerk/protocol/http/TRRServiceChannel.cpp
+++ b/netwerk/protocol/http/TRRServiceChannel.cpp
@@ -30,6 +30,8 @@
 #include "TRR.h"
 #include "TRRService.h"
 
+#include "nsString.h"
+
 namespace mozilla::net {
 
 NS_IMPL_ADDREF(TRRServiceChannel)
@@ -50,6 +52,12 @@ bool TRRServiceChannel::DispatchRelease() {
   return true;
 }
 
+NS_IMETHODIMP
+TRRServiceChannel::GetPostDataText(nsAString& aPostDataText) {
+  aPostDataText.Assign(NS_ConvertUTF8toUTF16(""));
+  return NS_OK;
+}
+
 NS_IMETHODIMP_(MozExternalRefCountType)
 TRRServiceChannel::Release() {
   nsrefcnt count = mRefCnt - 1;
diff --git a/netwerk/protocol/http/TRRServiceChannel.h b/netwerk/protocol/http/TRRServiceChannel.h
index d9365a592a..5b7e6b4911 100644
--- a/netwerk/protocol/http/TRRServiceChannel.h
+++ b/netwerk/protocol/http/TRRServiceChannel.h
@@ -47,6 +47,7 @@ class TRRServiceChannel : public HttpBaseChannel,
   NS_DECL_NSIPROTOCOLPROXYCALLBACK
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_TRRSERVICECHANNEL_IID)
 
+    NS_IMETHOD GetPostDataText(nsAString& aPostDataText) override;
   // nsIRequest
   NS_IMETHOD SetCanceledReason(const nsACString& aReason) override;
   NS_IMETHOD GetCanceledReason(nsACString& aReason) override;
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
index e4479400a4..252666a0ae 100644
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -144,6 +144,16 @@
 #  include "mozilla/StaticPrefs_fuzzing.h"
 #endif
 
+#include "nsStreamUtils.h" // For NS_ReadInputStreamToString
+
+//#include "mozilla/StaticString.h"
+#include "nsIVariant.h"
+#include "nsString.h"
+//#include "nsIWritableVariant.h"
+#include "nsServiceManagerUtils.h"
+#include "nsILoadInfo.h"
+#include "nsIPropertyBag2.h" // For QI to property bag
+
 namespace mozilla {
 
 using namespace dom;
@@ -6671,6 +6681,160 @@ nsHttpChannel::AsyncOpen(nsIStreamListener* aListener) {
   NS_ENSURE_TRUE(!LoadIsPending(), NS_ERROR_IN_PROGRESS);
   NS_ENSURE_TRUE(!LoadWasOpened(), NS_ERROR_ALREADY_OPENED);
 
+  nsString key;
+  key.AssignLiteral("postDataText"); // Define once, ASCII
+
+
+  printf("!!!! in nsHttpChannel::AsyncOpen before the aborted check...\n");
+  if (mCanceled && mStatus == NS_BINDING_ABORTED) {
+    printf("!!!! Cancelled via NS_BINDING_ABORTED\n");
+    if (mUploadStream) {
+      nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
+      nsAutoCString body; // Change to nsAutoCString for UTF-8
+      nsresult rv;
+
+      // Try to clone the stream to avoid consuming it
+      nsCOMPtr<nsIInputStream> clonedStream;
+      rv = NS_CloneInputStream(mUploadStream, getter_AddRefs(clonedStream));
+      if (NS_SUCCEEDED(rv) && clonedStream) {
+        rv = NS_ReadInputStreamToString(clonedStream, body, -1); // -1 reads entire stream
+        if (NS_SUCCEEDED(rv)) {
+          mPostDataText = body; // Already nsCString
+                                //printf("Captured POST payload: %s\n", mPostDataText.get());
+          printf("Captured1 aborted cloned POST from .cpp so mPostDataText set to: %s\n", mPostDataText.get());
+          nsString postDataTextValue = NS_ConvertUTF8toUTF16(mPostDataText);
+          if (mLoadInfo) {
+            // Create nsIWritableVariant
+            nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+            if (variant) {
+              nsresult rv = variant->SetAsAString(postDataTextValue); // Setter!
+              if (NS_SUCCEEDED(rv)) {
+                // Query mLoadInfo for nsIPropertyBag2
+                nsCOMPtr<nsIWritablePropertyBag> propBag = do_QueryInterface(mLoadInfo);
+                if (propBag) {
+                  rv = propBag->SetProperty(key, variant);
+                  if (NS_FAILED(rv)) {
+                    printf("SetProperty on loadInfo failed: %08x\n", static_cast<unsigned>(rv));
+                  } else {
+                    printf("Successfully set postDataText in loadInfo: %s\n", mPostDataText.get());
+                  }
+                } else {
+                  printf("Failed to QI mLoadInfo to nsIPropertyBag2\n");
+                }
+              } else {
+                printf("SetAsAString failed: %08x\n", static_cast<unsigned>(rv));
+              }
+            } else {
+              printf("do_CreateInstance failed for nsIWritableVariant\n");
+            }
+          } else {
+            printf("mLoadInfo is null, cannot store postDataText\n");
+          }
+//          if (mLoadInfo) {
+//            // Create nsIWritableVariant
+//            nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+//            if (variant) {
+//              nsresult rv = variant->SetAsAString(postDataTextValue); // Setter!
+//              if (NS_SUCCEEDED(rv)) {
+//                //rv = SetProperty(key, variant);
+//                rv = mLoadInfo->SetAnnotation(key, variant);
+//                if (NS_FAILED(rv)) {
+//                  printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+//                }
+//              } else {
+//                printf("SetAsAString failed: %08x\n", static_cast<unsigned>(rv));
+//              }
+//            } else {
+//              printf("do_CreateInstance failed for nsIWritableVariant\n");
+//            }
+//          }
+
+//          // Pass to network event (for JS)
+//    if (mNetworkEventOptions) {
+//      mNetworkEventOptions->SetPostDataText(postDataTextValue); // Hypothetical
+//    }
+//    // Store it in mLoadInfo annotations
+//    if (mLoadInfo) {
+//      //nsString key = NS_LITERAL_STRING("postDataText");
+//      nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+//      if (variant) {
+//        variant->SetAsAString(postDataTextValue);
+//        mLoadInfo->SetAnnotation(key, variant);
+//      }
+//    }
+//          // Create nsIVariant
+//    nsCOMPtr<nsIVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+//    if (variant) {
+//      nsresult rv = variant->SetAsString(postDataTextValue); // Fixed typo
+//      if (NS_SUCCEEDED(rv)) {
+//        rv = SetProperty(key, variant);
+//        if (NS_FAILED(rv)) {
+//          printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+//        }
+//      } else {
+//        printf("SetAsString failed: %08x\n", static_cast<unsigned>(rv));
+//      }
+//    } else {
+//      printf("do_CreateInstance failed for nsIVariant\n");
+//    }
+//          // Create nsIVariant
+//          nsCOMPtr<nsIVariant> variant;
+//          nsresult rv = NS_NewVariant(getter_AddRefs(variant));
+//          if (NS_SUCCEEDED(rv)) {
+//            rv = variant->SetAsAString(postDataTextValue);
+//            if (NS_SUCCEEDED(rv)) {
+//              rv = SetProperty(key, variant);
+//              if (NS_FAILED(rv)) {
+//                printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+//              }
+//            } else {
+//              printf("SetAsAString failed: %08x\n", static_cast<unsigned>(rv));
+//            }
+//          } else {
+//            printf("NS_NewVariant failed: %08x\n", static_cast<unsigned>(rv));
+//          }
+          //nsresult rv = SetProperty(key, postDataTextValue);
+          //nsresult rv = SetProperty(NS_LITERAL_STRING("postDataText"), postDataTextValue);
+          //if (NS_FAILED(rv)) {
+          //  printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+          //}
+        }
+      } else if (seekable) {
+        // Fallback for seekable streams
+        seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
+        rv = NS_ReadInputStreamToString(mUploadStream, body, -1);
+        if (NS_SUCCEEDED(rv)) {
+          mPostDataText = body;
+          //printf("Captured POST payload: %s\n", mPostDataText.get());
+          printf("Captured2 aborted seekable POST from .cpp so mPostDataText set to: %s\n", mPostDataText.get());
+          seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0); // Reset stream
+          nsString postDataTextValue = NS_ConvertUTF8toUTF16(mPostDataText);
+//          nsresult rv = SetProperty(key, postDataTextValue);
+//          //nsresult rv = SetProperty(NS_LITERAL_STRING("postDataText"), postDataTextValue);
+//          if (NS_FAILED(rv)) {
+//            printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+//          }
+          // Create nsIWritableVariant
+          nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+          if (variant) {
+            nsresult rv = variant->SetAsAString(postDataTextValue); // Setter!
+            if (NS_SUCCEEDED(rv)) {
+              rv = SetProperty(key, variant);
+              if (NS_FAILED(rv)) {
+                printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+              }
+            } else {
+              printf("SetAsAString failed: %08x\n", static_cast<unsigned>(rv));
+            }
+          } else {
+            printf("do_CreateInstance failed for nsIWritableVariant\n");
+          }
+        }
+      }
+    }//if
+    printf("!!!!!!!!!!!! Aborted with payload: %s\n", (!mPostDataText.IsEmpty() ? mPostDataText.get() : "null"));
+  }//if cancelled via aborted
+
   if (mCanceled) {
     ReleaseListeners();
     return NS_FAILED(mStatus) ? mStatus : NS_ERROR_FAILURE;
@@ -6680,6 +6844,125 @@ nsHttpChannel::AsyncOpen(nsIStreamListener* aListener) {
     return NS_OK;
   }
 
+  // Add payload capture here
+  printf("!!!! in nsHttpChannel::AsyncOpen before payload capture\n");
+  if (mUploadStream) {
+    nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
+    nsAutoCString body; // Change to nsAutoCString for UTF-8
+    nsresult rv;
+
+    // Try to clone the stream to avoid consuming it
+    nsCOMPtr<nsIInputStream> clonedStream;
+    rv = NS_CloneInputStream(mUploadStream, getter_AddRefs(clonedStream));
+    if (NS_SUCCEEDED(rv) && clonedStream) {
+      rv = NS_ReadInputStreamToString(clonedStream, body, -1); // -1 reads entire stream
+      if (NS_SUCCEEDED(rv)) {
+        mPostDataText = body; // Already nsCString
+        //printf("Captured POST payload: %s\n", mPostDataText.get());
+        printf("Captured3 cloned POST from .cpp so mPostDataText set to: %s\n", mPostDataText.get());
+        nsString postDataTextValue = NS_ConvertUTF8toUTF16(mPostDataText);
+//        nsresult rv = SetProperty(key, postDataTextValue);
+//        //nsresult rv = SetProperty(NS_LITERAL_STRING("postDataText"), postDataTextValue);
+//        //mozilla::StaticString key(u"postDataText"); // UTF-16 literal
+//        //nsresult rv = SetProperty(key, postDataTextValue);
+//        if (NS_FAILED(rv)) {
+//          printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+//        }
+//          // Create nsIWritableVariant
+//          nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+//          if (variant) {
+//            nsresult rv = variant->SetAsAString(postDataTextValue); // Setter!
+//            if (NS_SUCCEEDED(rv)) {
+//              rv = SetProperty(key, variant);
+//              if (NS_FAILED(rv)) {
+//                printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+//              }
+//            } else {
+//              printf("SetAsAString failed: %08x\n", static_cast<unsigned>(rv));
+//            }
+//          } else {
+//            printf("do_CreateInstance failed for nsIWritableVariant\n");
+//          }
+        if (mLoadInfo) {
+          nsresult rv = mLoadInfo->SetCustomPostDataText(postDataTextValue);
+          if (NS_FAILED(rv)) {
+            printf("SetCustomPostDataText failed: %08x\n", static_cast<unsigned>(rv));
+          } else {
+            // Changed: Read back customPostDataText for logging
+            nsAutoString customValue;
+            rv = mLoadInfo->GetCustomPostDataText(customValue);
+            if (NS_SUCCEEDED(rv)) {
+              printf("Successfully set customPostDataText in loadInfo: %s\n",
+                  NS_ConvertUTF16toUTF8(customValue).get());
+            } else {
+              printf("GetCustomPostDataText failed after set: %08x\n", static_cast<unsigned>(rv));
+            }
+          }//else
+        } else {
+          printf("mLoadInfo is null, cannot store postDataText\n");
+        }
+//          if (mLoadInfo) {
+//            // Create nsIWritableVariant
+//            nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+//            if (variant) {
+//              nsresult rv = variant->SetAsAString(postDataTextValue); // Setter!
+//              if (NS_SUCCEEDED(rv)) {
+//                // Query mLoadInfo for nsIPropertyBag2
+//                nsCOMPtr<nsIWritablePropertyBag> propBag = do_QueryInterface(mLoadInfo);
+//                if (propBag) {
+//                  rv = propBag->SetProperty(key, variant);
+//                  if (NS_FAILED(rv)) {
+//                    printf("SetProperty on loadInfo failed: %08x\n", static_cast<unsigned>(rv));
+//                  } else {
+//                    printf("Successfully set postDataText in loadInfo: %s\n", mPostDataText.get());
+//                  }
+//                } else {
+//                  printf("Failed to QI mLoadInfo to nsIPropertyBag2\n");
+//                }
+//              } else {
+//                printf("SetAsAString failed: %08x\n", static_cast<unsigned>(rv));
+//              }
+//            } else {
+//              printf("do_CreateInstance failed for nsIWritableVariant\n");
+//            }
+//          } else {
+//            printf("mLoadInfo is null, cannot store postDataText\n");
+//          }
+      }
+    } else if (seekable) {
+      // Fallback for seekable streams
+      seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
+      rv = NS_ReadInputStreamToString(mUploadStream, body, -1);
+      if (NS_SUCCEEDED(rv)) {
+        mPostDataText = body;
+        //printf("Captured POST payload: %s\n", mPostDataText.get());
+        printf("Captured4 seekable POST from .cpp so mPostDataText set to: %s\n", mPostDataText.get());
+        seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0); // Reset stream
+        nsString postDataTextValue = NS_ConvertUTF8toUTF16(mPostDataText);
+//        nsresult rv = SetProperty(key, postDataTextValue);
+//        //nsresult rv = SetProperty(NS_LITERAL_STRING("postDataText"), postDataTextValue);
+//        if (NS_FAILED(rv)) {
+//          printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+//        }
+          // Create nsIWritableVariant
+          nsCOMPtr<nsIWritableVariant> variant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+          if (variant) {
+            nsresult rv = variant->SetAsAString(postDataTextValue); // Setter!
+            if (NS_SUCCEEDED(rv)) {
+              rv = SetProperty(key, variant);
+              if (NS_FAILED(rv)) {
+                printf("SetProperty failed: %08x\n", static_cast<unsigned>(rv));
+              }
+            } else {
+              printf("SetAsAString failed: %08x\n", static_cast<unsigned>(rv));
+            }
+          } else {
+            printf("do_CreateInstance failed for nsIWritableVariant\n");
+          }
+      }
+    }
+  }
+
   MOZ_ASSERT(NS_IsMainThread());
 
   if (!gHttpHandler->Active()) {
@@ -6771,6 +7054,18 @@ nsHttpChannel::AsyncOpen(nsIStreamListener* aListener) {
   return NS_OK;
 }
 
+//NS_IMETHODIMP
+//nsHttpChannel::GetPostDataText(nsAString& aPostDataText) {
+//  aPostDataText = mPostDataText;
+//  return NS_OK;
+//}
+NS_IMETHODIMP
+nsHttpChannel::GetPostDataText(nsAString& aPostDataText) {
+  printf("GetPostDataText called, mPostDataText: %s\n", mPostDataText.get());
+  aPostDataText = NS_ConvertUTF8toUTF16(mPostDataText);
+  return NS_OK;
+}
+
 void nsHttpChannel::AsyncOpenFinal(TimeStamp aTimeStamp) {
   // We save this timestamp from outside of the if block in case we enable the
   // profiler after AsyncOpen().
diff --git a/netwerk/protocol/http/nsHttpChannel.h b/netwerk/protocol/http/nsHttpChannel.h
index cb8b8b7406..a187bb1237 100644
--- a/netwerk/protocol/http/nsHttpChannel.h
+++ b/netwerk/protocol/http/nsHttpChannel.h
@@ -102,6 +102,9 @@ class nsHttpChannel final : public HttpBaseChannel,
       nsACString& aServerResponseHeader) override;
   NS_IMETHOD GetProxyChallenges(nsACString& aChallenges) override;
   NS_IMETHOD GetWWWChallenges(nsACString& aChallenges) override;
+  
+  NS_IMETHOD GetPostDataText(nsAString& aPostDataText) override;
+
   NS_IMETHOD SetProxyCredentials(const nsACString& aCredentials) override;
   NS_IMETHOD SetWWWCredentials(const nsACString& aCredentials) override;
   NS_IMETHOD OnAuthAvailable() override;
@@ -849,6 +852,7 @@ class nsHttpChannel final : public HttpBaseChannel,
   Maybe<nsCOMPtr<nsIDNSHTTPSSVCRecord>> mHTTPSSVCRecord;
 
  protected:
+    nsCString mPostDataText; // ADDED: Store POST payload
   virtual void DoNotifyListenerCleanup() override;
 
   // Override ReleaseListeners() because mChannelClassifier only exists
diff --git a/netwerk/protocol/http/nsIHttpChannel.idl b/netwerk/protocol/http/nsIHttpChannel.idl
index a8372ba080..ff151bd5b5 100644
--- a/netwerk/protocol/http/nsIHttpChannel.idl
+++ b/netwerk/protocol/http/nsIHttpChannel.idl
@@ -24,6 +24,7 @@ native UniqueProfileChunkedBuffer(mozilla::UniquePtr<mozilla::ProfileChunkedBuff
 [builtinclass, scriptable, uuid(c5a4a073-4539-49c7-a3f2-cec3f0619c6c)]
 interface nsIHttpChannel : nsIIdentChannel
 {
+  void getPostDataText(out AString aPostDataText);
     /**************************************************************************
      * REQUEST CONFIGURATION
      *
diff --git a/netwerk/protocol/viewsource/nsViewSourceChannel.cpp b/netwerk/protocol/viewsource/nsViewSourceChannel.cpp
index d38cc43586..29e4765597 100644
--- a/netwerk/protocol/viewsource/nsViewSourceChannel.cpp
+++ b/netwerk/protocol/viewsource/nsViewSourceChannel.cpp
@@ -19,6 +19,8 @@
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 
+#include "nsString.h"
+
 NS_IMPL_ADDREF(nsViewSourceChannel)
 NS_IMPL_RELEASE(nsViewSourceChannel)
 /*
@@ -45,6 +47,12 @@ NS_INTERFACE_MAP_BEGIN(nsViewSourceChannel)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIViewSourceChannel)
 NS_INTERFACE_MAP_END
 
+NS_IMETHODIMP
+nsViewSourceChannel::GetPostDataText(nsAString& aPostDataText) {
+  aPostDataText.Assign(NS_ConvertUTF8toUTF16(""));
+  return NS_OK;
+}
+
 static nsresult WillUseExternalProtocolHandler(nsIIOService* aIOService,
                                                const char* aScheme) {
   nsCOMPtr<nsIProtocolHandler> handler;
diff --git a/netwerk/protocol/viewsource/nsViewSourceChannel.h b/netwerk/protocol/viewsource/nsViewSourceChannel.h
index 87c490f6b7..3ba43b499a 100644
--- a/netwerk/protocol/viewsource/nsViewSourceChannel.h
+++ b/netwerk/protocol/viewsource/nsViewSourceChannel.h
@@ -48,6 +48,8 @@ class nsViewSourceChannel final : public nsIViewSourceChannel,
   NS_FORWARD_SAFE_NSIFORMPOSTACTIONCHANNEL(mPostChannel)
   NS_FORWARD_SAFE_NSIHTTPCHANNELINTERNAL(mHttpChannelInternal)
 
+//  NS_IMETHOD GetPostDataText(nsAString& aPostDataText) override;
+
   // nsViewSourceChannel methods:
   nsViewSourceChannel() = default;
 
